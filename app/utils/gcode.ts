/**
 * @desc main controll of gcode
 */

import { PrintModeInfo } from './type'

const DEFAULT_FILL_ENABLED = false;
const DEFAULT_FILL_DENSITY = 4;
const ABSENT_VALUE = 896745231

const DEFAULT_TEXT_CONFIG = {
  optimizePath: false,
  fillEnabled: DEFAULT_FILL_ENABLED,
  fillDensity: DEFAULT_FILL_DENSITY,
  text: 'Xmake',
  size: 24,
  font: 'Georgia',
  lineHeight: 1.5,
  alignment: 'left' // left, middle, right
};


// get gcode header
export function getGcodeHeader() {
  const date = new Date();
  return [
    '; G-code for laser engraving',
    '; Generated by wemake team',
    `; ${date.toDateString()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`,
    '\n'
  ].join('\n');
}

// generate default config of laser print
export function generateLaserDefaults(mode: string, sourceType: 'svg' | 'raster' | 'text') {
  let config = null;
  let gcodeConfig = null;
  switch (mode) {
    case 'bw': {
      config = {
        invertGreyscale: false,
        bwThreshold: 168,
        density: DEFAULT_FILL_DENSITY,
        direction: 'Horizontal'
      };
      break;
    }
    case 'greyscale': {
      config = {
        invertGreyscale: false,
        contrast: 50,
        brightness: 50,
        whiteClip: 255,
        bwThreshold: 168,
        algorithm: 'FloydSteinburg',
        movementMode: 'greyscale-line', // greyscale-line, greyscale-dot
        density: DEFAULT_FILL_DENSITY
      };
      break;
    }
    case 'vector': {
      switch (sourceType) {
        case 'raster': {
          config = {
            optimizePath: true,
            fillEnabled: DEFAULT_FILL_ENABLED,
            fillDensity: DEFAULT_FILL_DENSITY,
            vectorThreshold: 128,
            isInvert: false,
            turdSize: 2
          };
          break;
        }
        case 'svg': {
          config = {
            optimizePath: false,
            fillEnabled: DEFAULT_FILL_ENABLED,
            fillDensity: DEFAULT_FILL_DENSITY
          };
          break;
        }
        case 'text': {
          config = { ...DEFAULT_TEXT_CONFIG };
          break;
        }
        default:
          break;
      }
      break;
    }
    case 'trace': {
      config = {
        optimizePath: false,
        fillEnabled: DEFAULT_FILL_ENABLED,
        fillDensity: DEFAULT_FILL_DENSITY
      };
      break;
    }
    default:
      break;
  }

  if (mode === 'greyscale') {
    gcodeConfig = {
      // Default movement mode is greyscale-line
      // greyscale-line: workSpeed: 500, dwellTime: null
      // greyscale-dot: workSpeed: null, dwellTime: 42
      jogSpeed: 1500,
      workSpeed: 500,
      plungeSpeed: ABSENT_VALUE,
      dwellTime: ABSENT_VALUE,
      fixedPowerEnabled: false,
      fixedPower: 100,
      multiPassEnabled: false,
      multiPasses: 2,
      multiPassDepth: 1
    };
  } else {
    gcodeConfig = {
      jogSpeed: 1500,
      workSpeed: 220,
      plungeSpeed: ABSENT_VALUE,
      dwellTime: ABSENT_VALUE,
      fixedPowerEnabled: false,
      fixedPower: 100,
      multiPassEnabled: false,
      multiPasses: 2,
      multiPassDepth: 1
    };
  }
  return { config, gcodeConfig };
};

// trans img to gcode & generate to path obj by print mode
export async function generateToolPathObj(modeInfo: PrintModeInfo, modelPath) {
  const { mode, config } = modeInfo;
  const { movementMode } = config;

  let fakeGcode = getGcodeHeader();

  fakeGcode += 'G90\n'; // absolute position
  fakeGcode += 'G21\n'; // millimeter units

  let workingGcode = '';
  if (mode === 'bw' || (mode === 'greyscale' && movementMode === 'greyscale-line')) {
    // workingGcode = await generateGcodeBW(modelInfo, modelPath);
  } else if (mode === 'greyscale') {
    // workingGcode = await generateGcodeGreyscale(modelInfo, modelPath);
  } else if (mode === 'vector' || mode === 'trace') {
    // workingGcode = await generateGcodeVector(modelInfo, modelPath);
  } else {
    return Promise.reject(new Error(`Unsupported process mode: ${mode}`));
  }

  fakeGcode += '; G-code START <<<\n';
  fakeGcode += `${workingGcode}\n`;
  fakeGcode += '; G-code END <<<\n';

  // const toolPathObject = new GcodeParser().parseGcodeToToolPathObj(fakeGcode, modelInfo);
  // return toolPathObject;
}
